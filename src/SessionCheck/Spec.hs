{-# LANGUAGE GADTs, TypeOperators #-}
module SessionCheck.Spec where

import Control.Monad
import Control.DeepSeq

import SessionCheck.Classes
import SessionCheck.Predicate

-- Specifications of protocols
data Spec t a where
  Get    :: (a :< t, NFData a) => Predicate a -> Spec t a
  Send   :: (a :< t, NFData a) => Predicate a -> Spec t a
  Async  :: Spec t a -> Spec t ()
  Stop   :: Spec t a
  Fail   :: String -> Spec t a
  -- Monadic fragment
  Return :: a -> Spec t a
  Bind   :: Spec t a -> (a -> Spec t b) -> Spec t b

-- Monads, Gonads, Applicatives, Functors and all that...
instance Monad (Spec t) where
  return = Return
  (>>=)  = Bind
  fail   = Fail

instance Applicative (Spec t) where
  pure  = Return
  (<*>) = ap

instance Functor (Spec t) where
  fmap = liftM

-- Recevie a value which satisfies a predicate
get :: (a :< t, NFData a) => Predicate a -> Spec t a
get = Get

-- Send a value which satisfies a predicate
send :: (a :< t, NFData a) => Predicate a -> Spec t a
send = Send

-- Run a protocol "in parallel" on the same channel
async :: Spec t a -> Spec t ()
async = Async

-- Terminate a session (or a sub-session generated by `interleave`)
stop :: Spec t a
stop = Stop

-- The dual of a specification, `dual . dual = id`
dual :: Spec t a -> Spec t a
dual s = case s of
  Get p    -> Send p
  Send p   -> Get p
  Async s  -> Async (dual s)
  Stop     -> Stop
  Return a -> Return a
  Bind s f -> Bind (dual s) (dual . f)

-- Representation of threads which hide the intermediate types
data Thread t where
  Hide :: Spec t a -> (a -> Spec t b) -> Thread t

-- Simply hide a Spec
hide :: Spec t a -> Thread t
hide s = Hide s (\_-> Stop)

------- Derived combinators for constructing specifications -------

-- Make a choice of one of the elements in the list
choose :: (Eq a, Show a, a :< b, NFData a) => [a] -> Spec b a
choose = send . choiceOf 

-- The other party makes a choice of one of the elements in the list
branch :: (Eq a, Show a, a :< b, NFData a) => [a] -> Spec b a
branch = dual . choose
